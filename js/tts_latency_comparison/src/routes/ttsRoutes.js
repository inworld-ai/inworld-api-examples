import express from 'express';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import { fileURLToPath } from 'url';

// Import graph manager and audio manager for serving audio files
import { graphManager } from '../managers/graphManager.js';
import AudioManager from '../managers/audioManager.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function createTTSRoutes(sessionManager) {
  const router = express.Router();

// Serve the main HTML page
router.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '../../public', 'index.html'));
});

// Serve audio files generated by graph nodes
router.get('/api/audio/:sessionId/:model', (req, res) => {
  const { sessionId, model } = req.params;
  
  // Get audio manager from the graph
  const audioManager = graphManager.ttsGraph?.audioManager;
  if (!audioManager) {
    return res.status(500).json({ error: 'Audio manager not available' });
  }
  
  const audioData = audioManager.getAudio(sessionId, model);
  if (audioData) {
    res.setHeader('Content-Type', 'audio/mpeg');
    res.setHeader('Content-Length', audioData.length);
    res.setHeader('Accept-Ranges', 'bytes');
    res.setHeader('Cache-Control', 'no-cache');
    res.send(audioData);
  } else {
    res.status(404).json({ error: 'Audio not found' });
  }
});

  // SSE endpoint for streaming TTS progress
  router.get('/api/tts/stream', (req, res) => {
    const sessionId = req.query.sessionId;
    console.log(`[Routes] SSE connection request for session ${sessionId}`);
    
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*'
    });

    // Send initial connection message
    const connectMessage = { type: 'connected', sessionId };
    res.write(`data: ${JSON.stringify(connectMessage)}\n\n`);
    console.log(`[Routes] Sent connection message to ${sessionId}`);

    // Add client to session
    sessionManager.addClient(sessionId, res);
    console.log(`[Routes] Added client to session ${sessionId}`);

    // Clean up on disconnect
    req.on('close', () => {
      console.log(`[Routes] Client disconnected from session ${sessionId}`);
      sessionManager.removeClient(sessionId, res);
    });
  });

  // TTS comparison endpoint using Inworld Runtime Graph
  router.post('/compare', async (req, res) => {
    const { text, voice } = req.body;
    const sessionId = req.headers['x-session-id'] || uuidv4();

    if (!text) {
      return res.status(400).json({ error: 'Text is required' });
    }

    try {
      // Check if graph manager is initialized
      if (!graphManager.isInitialized()) {
        throw new Error('Graph manager not initialized');
      }

    // Send initial status in format frontend expects
    console.log(`[Routes] Sending start message to session ${sessionId}`);
    sessionManager.sendUpdate(sessionId, {
      type: 'start',
      models: ['cartesia', 'elevenlabs-multilingual', 'hume', 'inworld', 'inworldmax'],
      timestamp: Date.now()
    });

    // Run TTS comparison through the graph (this will handle all SSE updates)
    console.log(`[Routes] Starting graph execution for session ${sessionId}`);
    const results = await graphManager.runTTSComparison(text, sessionId, voice);
    console.log(`[Routes] Graph execution completed for session ${sessionId}`);
    
    // Final complete message is sent by the ranking node
      
      // The graph handles sending updates to the frontend via SSE
      // Just return the final response
      res.json({
        sessionId,
        message: 'TTS comparison started successfully',
        status: 'processing'
      });

    } catch (error) {
      console.error('TTS comparison error:', error);
      
    sessionManager.sendUpdate(sessionId, {
      type: 'tts_comparison_error',
      data: { error: error.message }
    });

      res.status(500).json({ error: error.message });
    }
  });

  // Health check endpoint
  router.get('/health', (req, res) => {
    const graphStatus = graphManager.getStatus();
    res.json({ 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      graph: graphStatus
    });
  });

  return router;
}

export default createTTSRoutes;
